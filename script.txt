secret_kind = 0
secret_str = 0
saved_secret_kind = 0
saved_bdd = 0

// find the derive_secret function in the ncryptsslp module
findallmem 0, "48 8B C4 44 88 48 20 4C 89 40 18 48 89 50 10 53 56 41 54 41 55 41 56 41 57 48 81 EC A8 00 00 00 33 DB 33 F6 89 9C 24 E0 00 00 00 45 0F B6 E1 4D 8B F0 4C 8B F9 48 85 C9 0F 84 08 06 00 00 48 8B", -1, system
cmp $result, 0
je error

log "found Pattern"
addr = ref.addr(0)
log "Found Pattern at {p:addr}"

// set breakpoint on entry and attach custom callback
bp $addr
SetBreakpointCommand $addr, "scriptcmd call on_entry_cb"
ret

error:
msg "Pattern not found in ncryptsslp.dll"
ret

isnul:
msg "parameter is nul"
ret



// callback for setting return BP
on_entry_cb:
log "Entered Derive_secrets()"

// get the label and store it globally for use onreturn
set secret_kind, arg.get(1)
set saved_secret_kind, secret_kind
log "Label: {utf8@secret_kind}"

// Get the struct storing the secret
set mybdd, arg.get(12)
set saved_bdd, mybdd
log "mybdd: {p:mybdd}"

// set BP on return
ret_addr = [rsp]
bpx ret_addr
SetBreakpointCommand ret_addr, "scriptcmd call on_leave_cb"
run
ret



// callback on exit derive_secret
on_leave_cb:

// Compare first character to distinguish between client/server
cmp byte:[saved_secret_kind], 63  // 'c'
je check_client_traffic
cmp byte:[saved_secret_kind], 73  // 's' 
je check_server_traffic
run
ret

check_client_traffic:
secret_index = 12
// Check if it's "c hs traffic" or "c ap traffic"
cmp byte:[saved_secret_kind+2], 68  // 'h' (for "hs")
je set_wp
cmp byte:[saved_secret_kind+2], 61  // 'a' (for "ap") 
je set_wp
run
ret

check_server_traffic:
secret_index = 7
// Check if it's "s hs traffic" or "s ap traffic"  
cmp byte:[saved_secret_kind+2], 68  // 'h' (for "hs")
je set_wp
cmp byte:[saved_secret_kind+2], 61  // 'a' (for "ap")
je set_wp
run
ret


// Read the secret pointer from the structs and set a Wacthpoint on it 
// This part was taken from https://github.com/ngo/win-frida-scripts/blob/master/lsasslkeylog-easy/keylog.js
set_wp:
log "Setting WP for {utf8@saved_secret_kind}"

// Read struct_3lss
temp_addr = mybdd
temp_addr = temp_addr + 0x10
log "Reading struct_3lss from: {p:temp_addr}"
struct_3lss = [temp_addr]
log "struct_3lss: {p:struct_3lss}"

// Check if struct_3lss is valid
cmp struct_3lss, 0
je error_struct

// Read struct_RUUU
temp_addr = struct_3lss
temp_addr = temp_addr + 0x20
log "Reading struct_RUUU from: {p:temp_addr}"
struct_RUUU = [temp_addr]
log "struct_RUUU: {p:struct_RUUU}"

// Check if struct_RUUU is valid
cmp struct_RUUU, 0
je error_struct

// Read struct_YKSM
temp_addr = struct_RUUU
temp_addr = temp_addr + 0x10
log "Reading struct_YKSM from: {p:temp_addr}"
struct_YKSM = [temp_addr]
log "struct_YKSM: {p:struct_YKSM}"

// Check if struct_YKSM is valid
cmp struct_YKSM, 0
je error_struct

// Read size
temp_addr = struct_YKSM
temp_addr = temp_addr + 0x10
secret_size = dword:[temp_addr]
log "Secret size: {d:secret_size}"

// Read secret_ptr
temp_addr = struct_YKSM
temp_addr = temp_addr + 0x18
secret_ptr = [temp_addr]
log "secret_ptr: {p:secret_ptr}"

// Display the secret data using the actual size
log "Secret data ({d:secret_size} bytes): {hex@secret_ptr,secret_size}"

run
ret

error_struct:
log "Invalid pointer in structure chain"
run
ret